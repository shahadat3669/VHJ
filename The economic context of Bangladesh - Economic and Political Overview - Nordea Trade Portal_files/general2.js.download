// ***************************************************************************************************************
// ***************************************************************************************************************
// Librairie principale
// ***************************************************************************************************************
// ***************************************************************************************************************
// regroupe toutes les fonctions générales ainsi que les fonctions d'accès aux éléments DOM
// ***************************************************************************************************************
// ***************************************************************************************************************
// code pour conserver le codage UTF-8 dans C-génie : éàè



//---------------------------------------------------------------------------------------
// VARIABLES GLOBALES :
//		@profondeur_recursivite_max (int) : indique la profondeur maximale autorisée pour la fonction "convertir_objet_en_texte"
//---------------------------------------------------------------------------------------
var profondeur_recursivite_max=10;




var ua = window.navigator.userAgent;
var msie = ua.indexOf ( "MSIE " );
var version_du_navigateur = 6;

if ( msie > 0 )
	version_du_navigateur = parseInt( ua.substring (msie+5, ua.indexOf (".", msie )));
else
	version_du_navigateur = 100;




//---------------------------------------------------------------------------------------
// NOM FONCTION : copy_array
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function copy_array( source )
{
	// --------------
	// initialisation
	// --------------
	var destination = new Array();


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------


	// -----------
	// traitements
	// -----------
	for( var indice in source )
		if( ( typeof( source[indice] ) == "object" ) || ( typeof( source[indice] ) == "array" ) )
			destination[indice] = copy_array( source[indice] );
		else
			destination[indice] = source[indice];

	return destination;


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : supprimer_eventbubble
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function supprimer_eventbubble( event )
{
	// --------------
	// initialisation
	// --------------


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------


	// -----------
	// traitements
	// -----------
	if( typeof( window.event ) != 'undefined' )
		window.event.cancelBubble = true;
	else
		event.cancelBubble = true; 


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




if( typeof( HTMLElement ) != "undefined" )
	{
	if( typeof( HTMLElement.prototype.__defineSetter__ ) == 'function' )
		{
		HTMLElement.prototype.__defineSetter__("innerText", function (sText_old) {
			var sText = new String( sText_old );
			this.innerHTML = sText.replace(/\&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
		});
		HTMLElement.prototype.__defineGetter__("innerText", function () {
			var r = this.ownerDocument.createRange();
			r.selectNodeContents(this);
			return r.toString();
		});

		HTMLElement.prototype.__defineGetter__("outerHTML", function () {
			var _emptyTags = {
				"IMG":   true,
				"BR":    true,
				"INPUT": true,
				"META":  true,
				"LINK":  true,
				"PARAM": true,
				"HR":    true
				};
			var attrs = this.attributes;
			var str = "<" + this.tagName;
			for (var i = 0; i < attrs.length; i++)
				str += " " + attrs[i].name + "=\"" + attrs[i].value + "\"";

			if (_emptyTags[this.tagName])
				return str + ">";

			return str + ">" + this.innerHTML + "</" + this.tagName + ">";
		});
		HTMLElement.prototype.__defineSetter__("outerHTML", function (sHTML) {
			var r = this.ownerDocument.createRange();
			r.setStartBefore(this);
			var df = r.createContextualFragment(sHTML);
			this.parentNode.replaceChild(df, this);
		});
		}
	else
		{
		Object.defineProperty( HTMLElement.prototype, 'innerText',
			{
		    get: function() {
				var r = this.ownerDocument.createRange();
				r.selectNodeContents(this);
				return r.toString();
		    	},
		    set: function(sText_old) {
				var sText = new String( sText_old );
				this.innerHTML = sText.replace(/\&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
		    	}
			});

		Object.defineProperty( HTMLElement.prototype, 'outerHTML',
			{
		    get: function() {
				var _emptyTags = {
					"IMG":   true,
					"BR":    true,
					"INPUT": true,
					"META":  true,
					"LINK":  true,
					"PARAM": true,
					"HR":    true
					};
				var attrs = this.attributes;
				var str = "<" + this.tagName;
				for (var i = 0; i < attrs.length; i++)
					str += " " + attrs[i].name + "=\"" + attrs[i].value + "\"";

				if (_emptyTags[this.tagName])
					return str + ">";

				return str + ">" + this.innerHTML + "</" + this.tagName + ">";
		    	},
		    set: function(sHTML) {
				var r = this.ownerDocument.createRange();
				r.setStartBefore(this);
				var df = r.createContextualFragment(sHTML);
				this.parentNode.replaceChild(df, this);
		    	}
			});
		}
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : xreplace
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function xreplace( chaine_a_traiter, a_remplacer, remplacer_par )
{
	// --------------
	// initialisation
	// --------------
	var chaine_finale = "";
	var deb_capture = 0;
	var fin_capture = 0;


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------


	// -----------
	// traitements
	// -----------
	fin_capture = chaine_a_traiter.indexOf( a_remplacer );
	
	while( fin_capture > -1 )
		{
		chaine_finale += chaine_a_traiter.substring( deb_capture, fin_capture );
		chaine_finale += remplacer_par;
		deb_capture = fin_capture + a_remplacer.length
		fin_capture = chaine_a_traiter.indexOf( a_remplacer, deb_capture );
		}
	chaine_finale += chaine_a_traiter.substring( deb_capture );
	
	return chaine_finale + "";


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : hasAttribute
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function hasAttribute( objet, nom_attribut )
{
	// --------------
	// initialisation
	// --------------
	var retour = false;


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------
//	if( document.all )
if( version_du_navigateur < 8 )
		{
		if( nom_attribut == "class" )
			nom_attribut = "className";
		}
	else if( nom_attribut == "className" )
		nom_attribut = "class";


	// -----------
	// traitements
	// -----------
	try // code compatible DOM
		{
		retour = objet.hasAttribute( nom_attribut );
		}
	catch( ex ) // patch fait pour IE
		{
		if( typeof( objet[nom_attribut] ) != "undefined" )
			retour = true;
		else
			retour = false;
		}
	return retour;


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : getAttribute
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function getAttribute( objet, nom_attribut )
{
	// --------------
	// initialisation
	// --------------
	var retour = null;


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------
//	if( document.all )
if( version_du_navigateur < 8 )
		{
		if( nom_attribut == "class" )
			nom_attribut = "className";
		}
	else if( nom_attribut == "className" )
		nom_attribut = "class";


	// -----------
	// traitements
	// -----------
	try
		{
		retour = objet.getAttribute( nom_attribut );
		}
	catch( ex )
		{
		if( typeof( objet[nom_attribut] ) != "undefined" )
			retour = objet[nom_attribut];
		else
			retour = null;
		}
	return retour;


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : setAttribute
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function setAttribute( objet, nom_attribut, valeur )
{
	// --------------
	// initialisation
	// --------------


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------
//	if( document.all )
if( version_du_navigateur < 8 )
		{
		if( nom_attribut == "class" )
			nom_attribut = "className";
		}
	else if( nom_attribut == "className" )
		nom_attribut = "class";


	// -----------
	// traitements
	// -----------
	try
		{
		objet.setAttribute( nom_attribut, valeur );
		}
	catch( ex )
		{
		objet[nom_attribut] = valeur;
		}
	return true;


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : removeAttribute
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function removeAttribute( objet, nom_attribut )
{
	// --------------
	// initialisation
	// --------------


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------
//	if( document.all )
if( version_du_navigateur < 8 )
		{
		if( nom_attribut == "class" )
			nom_attribut = "className";
		}
	else if( nom_attribut == "className" )
		nom_attribut = "class";


	// -----------
	// traitements
	// -----------
	try
		{
		objet.removeAttribute( nom_attribut );
		}
	catch( ex )
		{
		
		}


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : getElementsByAttribute
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function getElementsByAttribute( nom_attribut, valeur )
{
	// --------------
	// initialisation
	// --------------
	var tabRetour = new Array();
	var tabTmp = new Array();


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------


	// -----------
	// traitements
	// -----------
	tabTmp = document.body.getElementsByTagName( "*" );
	j=0;
	for (i=0; i<tabTmp.length; i++)
		if( hasAttribute( tabTmp[i], nom_attribut ) )
			if( ( typeof( valeur ) == "undefined" )
				|| ( getAttribute( tabTmp[i], nom_attribut ) == valeur ) ) 
				{
				tabRetour[j] = tabTmp[i];
				j++;
				}

	return tabRetour; 


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : ajouter_evenement
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function ajouter_evenement( objet, evenement, fonction )
{
	// --------------
	// initialisation
	// --------------


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------


	// -----------
	// traitements
	// -----------
	if( document.all )
		objet.attachEvent( 'on' + evenement, fonction );
	else
		objet.addEventListener( evenement, fonction, false );


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




// Parcourt un objet ou un tableau et le transforme en une chaine de texte présentée (= print_r en PHP)
// Gère 
//		- les tableaux imbriqués
// 		- les types inconnus
// 		- un niveau de profondeur d'exploration maximum réglé en variable globale
// 		- les objets vides
//---------------------------------------------------------------------------------------
// NOM FONCTION : convertir_objet_en_texte
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function convertir_objet_en_texte( objet, profondeur_recursivite )
{
	// --------------
	// initialisation
	// --------------
	var texte;
	var texte_retour = "";
	var objet_vide = true;


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------


	// -----------
	// traitements
	// -----------
	if( typeof( profondeur_recursivite ) != "number" ) // rend le paramètre optionnel
		profondeur_recursivite = 0;
		
	if( typeof( objet ) == "object" )
		texte = "Objet :";
	else
		texte = "Tableau :";
		
	for( var indice in objet )
		{
		objet_vide = false;
		if( ( typeof( objet[indice] ) == "object" ) || ( typeof( objet[indice] ) == "array" ) )
			{
			texte_retour = "";
			if( profondeur_recursivite < profondeur_recursivite_max )
				{
				texte_retour = convertir_objet_en_texte( objet[indice], profondeur_recursivite + 1 );
				texte_retour = xreplace( texte_retour, "\r\n", "\r\n\t\t" );
				}
			else
				texte_retour = "Objet : -- PROFONDEUR MAX (" + profondeur_recursivite + ") DEPASSEE -> exploration non effectuée. --";
			}
		else
			{
			if( typeof( objet[indice] ) == "unknown" )
				texte_retour = "-- TYPE INCONNU -- ";
			else
				texte_retour = objet[indice];
			}
		texte = texte + "\r\n\t\t[" + indice + "] => " + texte_retour;
		}
	
	if( objet_vide == true )
		texte = texte + " -- VIDE -- ";
			
	return texte;

	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : debug
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 10/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function debug( variable )
{
	// --------------
	// initialisation
	// --------------
	var texte = "";


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------


	// -----------
	// traitements
	// -----------
	var type = typeof( variable );
	if( ( type == "object" ) || ( type == "array" ) )
		texte = convertir_objet_en_texte( variable );
	else
		texte = variable;

	if( document.getElementById( "debug" ) == null )
		{
		var mon_div = document.createElement( "DIV" );
		mon_div.className = "debug";
		mon_div.id = "debug";
		document.body.appendChild( mon_div );
		document.getElementById( "debug" ).innerText = "Zone de Debug\r\n";
		}
	document.getElementById( "debug" ).innerText += "\r\n" + texte;


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : FormatNumber2
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@num (float) : nombre à formater
//		@decimalNum (int) : nombre de chiffres après la virgule
//		@bolLeadingZero (boolean) : indique s'il faut laisser le zéro pour les nombres entre -1 exclus et 1 exclus
//		@bolParens (boolean) : indique s'il faut mettre des parenthéses autour des nombres négatifs
//		@bolCommas (boolean) : indique s'il faut mettre des "." comme séparateur de milliers
// NECESSITES :
// SORTIES :
// VALEURS DE RETOUR :	
//		* (string) : nombre formaté
// AUTEUR : INCONNU
// DERNIERE MODIF : 10/12/2005
// ETAT : ok
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function FormatNumber2( num, decimalNum, bolLeadingZero, bolParens, bolCommas )
{
	// --------------
	// initialisation
	// --------------
	var tmpNum = num;
	var iSign = num < 0 ? -1 : 1;


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------
	if( isNaN( parseInt( num ) ) )
		return "NaN";


	// -----------
	// traitements
	// -----------
	// on tronque le nombre pour avoir strictement le nombre de chiffres après la virgule demandée
	tmpNum *= Math.pow(10,decimalNum);
	tmpNum = Math.round(Math.abs(tmpNum))
	tmpNum /= Math.pow(10,decimalNum);
	// on remet le signe
	tmpNum *= iSign;
	
	
	// on crée une chaine de caractères avec le nombre
	var tmpNumStr = new String(tmpNum);

	// gestion de la présence du zéro pour les nombres entre -1 et 1
	if (!bolLeadingZero && num < 1 && num > -1 && num != 0)
		if (num > 0)
			tmpNumStr = tmpNumStr.substring(1,tmpNumStr.length);
		else
			tmpNumStr = "-" + tmpNumStr.substring(2,tmpNumStr.length);

	// remplacement du séparateur décimal "." par ","
	tmpNumStr = xreplace( tmpNumStr, ".", "," );

	// remplir après la virgule pour obtenir le nombre de chiffres voulus même avec un nombre comportant moins de précision
	var emplacement_du_point = tmpNumStr.indexOf(",");
	if( emplacement_du_point < 0 )
		{
		emplacement_du_point = tmpNumStr.length;
		tmpNumStr = tmpNumStr + ",";
		}
	for( var i=tmpNumStr.length-emplacement_du_point-1 ; i<decimalNum ; i++ )
		tmpNumStr = tmpNumStr + "0";

	// ajout du séparateur de milliers
	if (bolCommas && (num >= 1000 || num <= -1000)) {
		var iStart = tmpNumStr.indexOf(",");
		if (iStart < 0)
			iStart = tmpNumStr.length;

		iStart -= 3;
		while (iStart >= 1) {
			tmpNumStr = tmpNumStr.substring(0,iStart) + "." + tmpNumStr.substring(iStart,tmpNumStr.length)
			iStart -= 3;
		}		
	}

	// ajout des parenthéses sur les nombres négatifs
	if (bolParens && num < 0)
		tmpNumStr = "(" + tmpNumStr.substring(1,tmpNumStr.length) + ")";

	return tmpNumStr;


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}




//---------------------------------------------------------------------------------------
// NOM FONCTION : fermer_fenetre
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 17/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function fermer_fenetre(  )
{
	// --------------
	// initialisation
	// --------------


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------


	// -----------
	// traitements
	// -----------
	top.opener=self;
	top.close();


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}





//---------------------------------------------------------------------------------------
// NOM FONCTION : champ_ecrire_valeur
// DESCRIPTION COURTE :	met à jour la valeur d'un élément de formulaire
// DESCRIPTION :	
//		met à jour la valeur d'un élément de formulaire
// ENTREES :
//		@objet (objet) : pointeur sur l'objet dont il faut mettre à jour le contenu
//		@valeur (mixed) : nouveau contenu de l'élément de formulaire
// NECESSITES :
//		l'objet doit être un élément de formulaire.
// SORTIES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
//		* null : impossible d'écrire la valeur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 09/12/2005
// ETAT : ok
// RESTE A FAIRE :
//		* traiter les listes déroulantes à choix multiples
// REMARQUES :
// VOIR AUSSI : champ_lire_valeur champ_verifier_modification champ_restaurer_ancienne_valeur champ_memoriser_valeur champ_preparer preparer_tous_les_champs
//---------------------------------------------------------------------------------------
function champ_ecrire_valeur( objet, valeur )
{
	// --------------
	// initialisation
	// --------------
	var liste_elements = null;


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------
	// vérification du paramètre objet
	if( objet == null )
		// null : impossible de lire la valeur
		return null;


	// -----------
	// traitements
	// -----------
	valeur = lib_general__convertir_unicode_vers_js( valeur );
	if( objet.tagName == "SELECT" )
		{
		if( objet.options.length == 0 )
			{
			objet.selectedIndex = -1;
			return;
			}

		for( var i=0 ; i<objet.options.length ; i++ )
			if( objet.options[i].value == valeur )
				objet.selectedIndex = i;

		if( objet.options[objet.selectedIndex].value != valeur )
			objet.selectedIndex = -1;
		}

	if( objet.tagName == "TEXTAREA" )
		objet.value = valeur;

	if( objet.tagName == "INPUT" )
		{
		if( ( objet.type == "text" )
			|| ( objet.type == "password" )
			|| ( objet.type == "hidden" )
			|| ( objet.type == "button" ) )
			objet.value = valeur;

		if( ( objet.type == "radio" ) || ( objet.type == "checkbox" ) )
			{
			liste_elements = getElementsByAttribute( "name", objet.name );
			for( num_element=0 ; num_element<liste_elements.length ; num_element++ )
				if( liste_elements[num_element].value == valeur )
					liste_elements[num_element].checked = true;
				else
					liste_elements[num_element].checked = false;
//			champ_verifier_modification( objet );
//			objet.checked = valeur;
			}

		if( objet.type == "file" )
			{
			var parent = objet.parentNode;
			parent.innerHTML = parent.innerHTML;
			objet = parent.firstChild;
			}
		}

	//champ_verifier_modification( objet );		


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}





//---------------------------------------------------------------------------------------
// NOM FONCTION : champ_ecrire_valeur_tableau
// DESCRIPTION COURTE :	met à jour la valeur d'un ensemble de checkbox
// DESCRIPTION :	
//		met à jour la valeur d'un ensemble de checkbox depuis une chaine de caractères
// ENTREES :
//		@objet (objet) : pointeur sur l'objet dont il faut mettre à jour le contenu
//		@valeur (mixed) : nouveau contenu de l'élément de formulaire
// NECESSITES :
//		l'objet doit être un élément de formulaire.
// SORTIES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
//		* null : impossible d'écrire la valeur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 09/12/2005
// ETAT : ok
// RESTE A FAIRE :
//		* traiter les listes déroulantes à choix multiples
// REMARQUES :
// VOIR AUSSI : champ_lire_valeur champ_verifier_modification champ_restaurer_ancienne_valeur champ_memoriser_valeur champ_preparer preparer_tous_les_champs
//---------------------------------------------------------------------------------------
function champ_ecrire_valeur_tableau( objet, valeur )
{
	// --------------
	// initialisation
	// --------------
	var liste_elements = null;


	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------
	// vérification du paramètre objet
	if( objet == null )
		// null : impossible de lire la valeur
		return null;


	// -----------
	// traitements
	// -----------
	valeur = ';;;' + lib_general__convertir_unicode_vers_js( valeur ) + ';';
	if( objet.tagName == "INPUT" )
		if( ( objet.type == "radio" ) || ( objet.type == "checkbox" ) )
			{
			liste_elements = getElementsByAttribute( "name", objet.name );
			for( num_element=0 ; num_element<liste_elements.length ; num_element++ )
				if( valeur.indexOf(';' + liste_elements[num_element].value + ';') > 0 )
					liste_elements[num_element].checked = true;
				else
					liste_elements[num_element].checked = false;
			}


	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}

function verifier_format_code(valeur,format)
{
	if(format=='affichage')
		{
		 var code= valeur;
		code = code.replace(/\./g,'');
		var code_1 = code.substr(0,4);
		var code_2 = code.substr(4,2);
		var code_3 = code.substr(6,2);
		var code_4 = code.substr(8,2);
		var code_5 = code.substr(10,2);
		var code_6 = code.substr(12,2);
		var code_7 = code.substr(14,2);
		var code_8 = code.substr(16,2);
		code = code_1;
		if(code_2!='')
			code += '.'+code_2;
		if(code_3!='')
			code += '.'+code_3;
		if(code_4!='')
			 code += '.'+code_4;
		if(code_5!='')
			 code += '.'+code_5;
		if(code_6!='')
			 code += '.'+code_6;
		if(code_7!='')
			 code += '.'+code_7;
		if(code_8!='')
			 code += '.'+code_8;
		}
	if(format=='recherche')
		{		 
		var code= valeur;
		code = code.replace(/\./g,'');		
		}
	return code;
}

function MM_swapImgRestore() { //v3.0
  var i,x,a=document.MM_sr; for(i=0;a&&i<a.length&&(x=a[i])&&x.oSrc;i++) x.src=x.oSrc;
}

function MM_preloadImages() { //v3.0
  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();
    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)
    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];} }
}

function MM_findObj(n, d) { //v4.01
  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {
    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}
  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];
  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document);
  if(!x && d.getElementById) x=d.getElementById(n); return x;
}

function MM_swapImage() { //v3.0
  var i,j=0,x,a=MM_swapImage.arguments; document.MM_sr=new Array; for(i=0;i<(a.length-2);i+=3)
   if ((x=MM_findObj(a[i]))!=null){document.MM_sr[j++]=x; if(!x.oSrc) x.oSrc=x.src; x.src=a[i+2];}
}

function element_select__trier( nom_liste )
{
	var liste1 = new Array();
	var liste2 = new Array();

	for( var i=0 ; i<$( nom_liste ).options.length ; i++ )
		liste1[i] = { value: $( nom_liste ).options[i].value, text: $( nom_liste ).options[i].text };

	liste2 = $A( liste1 ).sortBy( function( valeur, indice )
		{
		if( valeur["value"] == "" )
			return "";
		return valeur["text"];
		});


	element_select__vider( nom_liste );

	for( var i=0 ; i<liste2.length ; i++ )
		element_select__ajouter_item( nom_liste, liste2[i]["text"], liste2[i]["value"] );
}

function element_select__vider( nom_liste )
{
	for( i=$(nom_liste).options.length-1 ; i>=0 ; i-- )
		$(nom_liste).remove( i );
	$(nom_liste).selectedIndex = 0;
}

function element_select__ajouter_item( nom_liste, texte, valeur )
{
	var mon_option = new Option( "", valeur ); 

	try
		{
		$( nom_liste ).add( mon_option, null ); // ne fonctionne pas sous IE
		}
	catch(ex)
		{
		$( nom_liste ).add( mon_option ); // fonctionne sous IE seulement
		}
	$( nom_liste ).options[$( nom_liste ).options.length-1].innerHTML = texte;
}


function lib_general__convertir_dec_hex( valeur )
{
	var reste = 0;
	var chaine = "";
	var lettres = new Array("0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G");

	while( valeur>15 )
		{
		reste = valeur - 16*Math.floor( valeur / 16 );
		valeur = Math.floor( valeur / 16 );
		chaine = lettres[reste] + chaine;
		}
	chaine = lettres[valeur] + chaine;

	return chaine;
}

function lib_general__forcer_a_quatre_caracteres( chaine )
{
	for( var i=chaine.length ; i<4 ; i++ )
		chaine = "0" + chaine;
	return chaine;
}

function lib_general__convertir_unicode_vers_js( mon_texte )
{
	var mon_texte_old = "";

	while( mon_texte_old != mon_texte )
		{
		mon_texte_old = mon_texte;

		mon_texte = mon_texte.replace( /&#x([0-9a-f][0-9a-f][0-9a-f][0-9a-f]);/, "\\u$1");
		mon_texte = mon_texte.replace( /&#x([0-9a-f][0-9a-f][0-9a-f]);/, "\\u0$1");
		mon_texte = mon_texte.replace( /&#x([0-9a-f][0-9a-f]);/, "\\u00$1");
		mon_texte = mon_texte.replace( /&#x([0-9a-f]);/, "\\u000$1");
		

		var tempo = {"nbsp":160,"iexcl":161,"cent":162,"pound":163,"curren":164,"yen":165,"brvbar":166,"sect":167,"uml":168,"copy":169,"ordf":170,"laquo":171,"not":172,"shy":173,"reg":174,"macr":175,"deg":176,"plusmn":177,"sup2":178,"sup3":179,"acute":180,"micro":181,"para":182,"middot":183,"cedil":184,"sup1":185,"ordm":186,"raquo":187,"frac14":188,"frac12":189,"frac34":190,"iquest":191,"Agrave":192,"Aacute":193,"Acirc":194,"Atilde":195,"Auml":196,"Aring":197,"AElig":198,"Ccedil":199,"Egrave":200,"Eacute":201,"Ecirc":202,"Euml":203,"Igrave":204,"Iacute":205,"Icirc":206,"Iuml":207,"ETH":208,"Ntilde":209,"Ograve":210,"Oacute":211,"Ocirc":212,"Otilde":213,"Ouml":214,"times":215,"Oslash":216,"Ugrave":217,"Uacute":218,"Ucirc":219,"Uuml":220,"Yacute":221,"THORN":222,"szlig":223,"agrave":224,"aacute":225,"acirc":226,"atilde":227,"auml":228,"aring":229,"aelig":230,"ccedil":231,"egrave":232,"eacute":233,"ecirc":234,"euml":235,"igrave":236,"iacute":237,"icirc":238,"iuml":239,"eth":240,"ntilde":241,"ograve":242,"oacute":243,"ocirc":244,"otilde":245,"ouml":246,"divide":247,"oslash":248,"ugrave":249,"uacute":250,"ucirc":251,"uuml":252,"yacute":253,"thorn":254,"yuml":255,"fnof":402,"Alpha":913,"Beta":914,"Gamma":915,"Delta":916,"Epsilon":917,"Zeta":918,"Eta":919,"Theta":920,"Iota":921,"Kappa":922,"Lambda":923,"Mu":924,"Nu":925,"Xi":926,"Omicron":927,"Pi":928,"Rho":929,"Sigma":931,"Tau":932,"Upsilon":933,"Phi":934,"Chi":935,"Psi":936,"Omega":937,"alpha":945,"beta":946,"gamma":947,"delta":948,"epsilon":949,"zeta":950,"eta":951,"theta":952,"iota":953,"kappa":954,"lambda":955,"mu":956,"nu":957,"xi":958,"omicron":959,"pi":960,"rho":961,"sigmaf":962,"sigma":963,"tau":964,"upsilon":965,"phi":966,"chi":967,"psi":968,"omega":969,"thetasym":977,"upsih":978,"piv":982,"bull":8226,"hellip":8230,"prime":8242,"Prime":8243,"oline":8254,"frasl":8260,"weierp":8472,"image":8465,"real":8476,"trade":8482,"alefsym":8501,"larr":8592,"uarr":8593,"rarr":8594,"darr":8595,"harr":8596,"crarr":8629,"lArr":8656,"uArr":8657,"rArr":8658,"dArr":8659,"hArr":8660,"forall":8704,"part":8706,"exist":8707,"empty":8709,"nabla":8711,"isin":8712,"notin":8713,"ni":8715,"prod":8719,"sum":8721,"minus":8722,"lowast":8727,"radic":8730,"prop":8733,"infin":8734,"ang":8736,"and":8743,"or":8744,"cap":8745,"cup":8746,"int":8747,"there4":8756,"sim":8764,"cong":8773,"asymp":8776,"ne":8800,"equiv":8801,"le":8804,"ge":8805,"sub":8834,"sup":8835,"nsub":8836,"sube":8838,"supe":8839,"oplus":8853,"otimes":8855,"perp":8869,"sdot":8901,"lceil":8968,"rceil":8969,"lfloor":8970,"rfloor":8971,"lang":9001,"rang":9002,"loz":9674,"spades":9824,"clubs":9827,"hearts":9829,"diams":9830,"quot":34,"amp":38,"lt":60,"gt":62,"OElig":338,"oelig":339,"Scaron":352,"scaron":353,"Yuml":376,"circ":710,"tilde":732,"ensp":8194,"emsp":8195,"thinsp":8201,"zwnj":8204,"zwj":8205,"lrm":8206,"rlm":8207,"ndash":8211,"mdash":8212,"lsquo":8216,"rsquo":8217,"sbquo":8218,"ldquo":8220,"rdquo":8221,"bdquo":8222,"dagger":8224,"Dagger":8225,"permil":8240,"lsaquo":8249,"rsaquo":8250,"euro":8364};
		for( var caractere in tempo )
			mon_texte = mon_texte.replace( "&" + caractere + ";", "\\u" + lib_general__forcer_a_quatre_caracteres( lib_general__convertir_dec_hex( tempo[caractere] ) ) );
	
		var chaine = mon_texte.match( /&#([0-9]+);/ );
		while( chaine != null )
			{
			mon_texte = mon_texte.replace( chaine[0], "\\u" + lib_general__forcer_a_quatre_caracteres( lib_general__convertir_dec_hex( chaine[1] ) ) );
			chaine = mon_texte.match( /&#([0-9]+);/ );
			}
		}

	mon_texte=xreplace(mon_texte,"\r","\\r");
	mon_texte=xreplace(mon_texte,"\n","\\n");
	mon_texte=xreplace(mon_texte,"\t","\\t");
	mon_texte=xreplace(mon_texte,"\'","\\\'");
	mon_texte=xreplace(mon_texte,"\"","\\\"");

	eval( "var texte='" + mon_texte + "';" );
	return texte;
}
//---------------------------------------------------------------------------------------
// NOM FONCTION : transmettre_log_service_automatise
// DESCRIPTION COURTE :	
// DESCRIPTION :	
//		.
// ENTREES :
//		@[nom_variable] (type) : 
//			STRUCT :
//				[][dflsdflk]
//				  [dqsdqd][]
//			VALEURS :
//				* false : truc
//				* 1 : truc
//				* "toto" : truc
//		VARIABLES GLOBALES :
// NECESSITES :
//		.
// SORTIES :
//		@nom_variable (type) : utilité
//		VARIABLES GLOBALES :
// VALEURS DE RETOUR :	
//		* 0 : aucune erreur
// AUTEUR : DANIEL Eric
// DERNIERE MODIF : 17/12/2005
// ETAT : dev
// RESTE A FAIRE :
//		*
// REMARQUES :
// VOIR AUSSI :
//---------------------------------------------------------------------------------------
function transmettre_log_service_automatise(id_service)
{

	// --------------
	// initialisation
	// --------------
	var	url="/commun/logs__services_automatises.php";
	var parametres="id_service="+id_service;
	// ------------------------------------
	// vérification des paramètres d'entrée
	// ------------------------------------

	// -----------
	// traitements
	// -----------
	var mon_ajax = new Ajax.Request(url, {method: 'get', parameters: parametres} );

	// ---------------------
	// sortie de la fonction
	// ---------------------
	// 0 : aucune erreur
	return 0;
}


function retrier_une_liste( objet, sens )
{
	var tempo = "";
	var liste_des_values = new Array();
	var liste_des_textes = new Array();
	var selection_courante = 0;
	var j = 0;

	for( var i=0 ; i<objet.options.length ; i++ )
		{
		liste_des_values[i] = objet.options[i].value;
		liste_des_textes[i] = objet.options[i].text;
		}

	selection_courante = liste_des_values[objet.selectedIndex];

	echange_effectue = true;
	while( echange_effectue )
		{
		echange_effectue = false;
		for( var i=1 ; i<objet.options.length ; i++ )
			if( liste_des_textes[i] < liste_des_textes[i-1] )
				{
				tempo = liste_des_values[i];
				liste_des_values[i] = liste_des_values[i-1];
				liste_des_values[i-1] = tempo;

				tempo = liste_des_textes[i];
				liste_des_textes[i] = liste_des_textes[i-1];
				liste_des_textes[i-1] = tempo;

				echange_effectue = true;
				}
		}

	for( var i=0 ; i<objet.options.length ; i++ )
		{
		if( sens == 1 )
			j = i;
		else
			j = objet.options.length-i-1;
		objet.options[i].value = liste_des_values[j];
		objet.options[i].text = liste_des_textes[j];
		if( objet.options[i].value == selection_courante )
			objet.selectedIndex = i;
		}
}


function Left(str, n)
{
	if (n <= 0)
		return "";
	else if (n > String(str).length)
		return str;
	else
		return String(str).substring(0,n);
}

function Right(str, n)
{
	if (n <= 0)
		return "";
	else if (n > String(str).length)
		return str;
	else
		{
		var iLen = String(str).length;
		return String(str).substring(iLen, iLen - n);
		}
}

function cacher_elements_sous_item( item )
{
	if( version_du_navigateur != 9 )
	{
	item.style.display='block';
	var taille_x = item.clientWidth;
	var taille_y = item.clientHeight;
	item.style.display='none';

	var oIframe = document.createElement("iframe");
	if( String( self.location ).substring( 0,5 ) == "https" )
		oIframe.src = "javascript:'<html><!-- InstanceEnd --></html>';";
	else
		oIframe.src = "about:blank";
	oIframe.className = "innerFixer";
	oIframe.style.width = taille_x +"px";
	oIframe.style.height = taille_y +"px";

	item.appendChild( oIframe );
	}
}

///////////////////////////////
// gestion de la pagination //
/////////////////////////////
var page_num_page_actuelle = 0;
var nbr_element_pagination = 0;
	
function page_montrer_page( num_page )
{
	console.log(nbr_element_pagination);
	milieu_element_pagination = Math.round(nbr_element_pagination/2);	
	interval_min = milieu_element_pagination - 1;
	interval_max = milieu_element_pagination + 1;
	dernier_prod = nbr_element_pagination - 2;
	page_num_page_actuelle = num_page;
	
	for( var cpt=1; cpt<=nbr_element_pagination; cpt++ )
	{
		if( nbr_element_pagination > 9 )
		{
			Element.hide( "span_texte__" + cpt );
			Element.hide( "span_texte2__" + cpt );
			
			if( cpt == num_page )
			{
				Element.show( "page_actu__" + cpt );
				Element.hide( "page_lien__" + cpt );
				Element.show( "page_texte__" + cpt );
				if( $("page_lien2__" + cpt) )
					Element.hide( "page_lien2__" + cpt );
				if( $("page_texte2__" + cpt) )
					Element.show( "page_texte2__" + cpt );
			}
			else if( ( cpt+1 == num_page ) || ( cpt-1 == num_page ) || ( cpt == nbr_element_pagination ) || ( cpt == nbr_element_pagination-1 ) || ( cpt == 1 ) || ( cpt == 2 ) )
			{
				Element.hide( "page_actu__" + cpt );
				Element.show( "page_lien__" + cpt );
				Element.hide( "page_texte__" + cpt );
				if( $("page_lien2__" + cpt) )
					Element.show( "page_lien2__" + cpt );
				if( $("page_texte2__" + cpt) )
					Element.hide( "page_texte2__" + cpt );
			}
			else
			{
				Element.hide( "page_actu__" + cpt );
				Element.hide( "page_lien__" + cpt );
				Element.hide( "page_texte__" + cpt );
				if( $("page_lien2__" + cpt) )
					Element.hide( "page_lien2__" + cpt );
				if( $("page_texte2__" + cpt) )
					Element.hide( "page_texte2__" + cpt );
			}
			
			var element_plus_2 = num_page + 2;
			var element_moins_2 = num_page - 2;
			if( ( $( "page_lien__" + element_plus_2 ) ) && ( $( "page_lien__" + element_plus_2 ).style.display == 'none' ) && ( $( "page_texte__" + element_plus_2 ).style.display == 'none' ) )
			{
				Element.show( "span_texte__" + element_plus_2 );
				Element.show( "span_texte2__" + element_plus_2 );
			}
			if( ( $( "page_lien__" + element_moins_2 ) ) && ( $( "page_lien__" + element_moins_2 ).style.display == 'none' ) && ( $( "page_texte__" + element_moins_2 ).style.display == 'none' ) )
			{
				Element.show( "span_texte__" + element_moins_2 );
				Element.show( "span_texte2__" + element_moins_2 );
			}
		}
		else
		{
			if( cpt == num_page )
			{
				Element.show( "page_actu__" + cpt );
				Element.hide( "page_lien__" + cpt );
				Element.show( "page_texte__" + cpt );
				if( $("page_lien2__" + cpt) )
					Element.hide( "page_lien2__" + cpt );
				if( $("page_texte2__" + cpt) )
					Element.show( "page_texte2__" + cpt );
			}
			else
			{
				Element.hide( "page_actu__" + cpt );
				Element.show( "page_lien__" + cpt );
				Element.hide( "page_texte__" + cpt );
				if( $("page_lien2__" + cpt) )
					Element.show( "page_lien2__" + cpt );
				if( $("page_texte2__" + cpt) )
					Element.hide( "page_texte2__" + cpt );
			}
		}
	}
}


function page__cacher_pages()
{	
	for(var i=1;i<=nbr_element_pagination;i++)
		Element.hide('page_actu__'+i);
}

function page_montrer_toutes_les_pages()
{	
	for(var i=1;i<=nbr_element_pagination;i++)
		Element.show('page_actu__'+i);
}

///////////////////////////////////////////////////
// gestion de la pagination pour un 2eme onglet //
/////////////////////////////////////////////////
var page_num_page_actuelle2 = 0;
var nbr_element_pagination2 = 0;
	
function page_montrer_page2( num_page )
{	
	milieu_element_pagination = Math.round(nbr_element_pagination2/2);	
	interval_min = milieu_element_pagination - 1;
	interval_max = milieu_element_pagination + 1;
	dernier_prod = nbr_element_pagination2 - 2;
	page_num_page_actuelle2 = num_page;
	
	for( var cpt=1; cpt<=nbr_element_pagination2; cpt++ )
	{
		if( nbr_element_pagination2 > 9 )
		{
			Element.hide( "span_texte3__" + cpt );
			Element.hide( "span_texte4__" + cpt );
			
			if( cpt == num_page )
			{
				Element.show( "page_actu2__" + cpt );
				Element.hide( "page_lien3__" + cpt );
				Element.show( "page_texte3__" + cpt );
				Element.hide( "page_lien4__" + cpt );
				Element.show( "page_texte4__" + cpt );
			}
			else if( ( cpt+1 == num_page ) || ( cpt-1 == num_page ) || ( cpt == nbr_element_pagination2 ) || ( cpt == nbr_element_pagination2-1 ) || ( cpt == 1 ) || ( cpt == 2 ) )
			{
				Element.hide( "page_actu2__" + cpt );
				Element.show( "page_lien3__" + cpt );
				Element.hide( "page_texte3__" + cpt );
				Element.show( "page_lien4__" + cpt );
				Element.hide( "page_texte4__" + cpt );
			}
			else
			{
				Element.hide( "page_actu2__" + cpt );
				Element.hide( "page_lien3__" + cpt );
				Element.hide( "page_texte3__" + cpt );
				Element.hide( "page_lien4__" + cpt );
				Element.hide( "page_texte4__" + cpt );
			}
			
			var element_plus_2 = num_page + 2;
			var element_moins_2 = num_page - 2;
			if( ( $( "page_lien3__" + element_plus_2 ) ) && ( $( "page_lien3__" + element_plus_2 ).style.display == 'none' ) && ( $( "page_texte3__" + element_plus_2 ).style.display == 'none' ) )
			{
				Element.show( "span_texte3__" + element_plus_2 );
				Element.show( "span_texte4__" + element_plus_2 );
			}
			if( ( $( "page_lien3__" + element_moins_2 ) ) && ( $( "page_lien3__" + element_moins_2 ).style.display == 'none' ) && ( $( "page_texte3__" + element_moins_2 ).style.display == 'none' ) )
			{
				Element.show( "span_texte3__" + element_moins_2 );
				Element.show( "span_texte4__" + element_moins_2 );
			}
		}
		else
		{
			if( cpt == num_page )
			{
				Element.show( "page_actu2__" + cpt );
				Element.hide( "page_lien3__" + cpt );
				Element.show( "page_texte3__" + cpt );
				Element.hide( "page_lien4__" + cpt );
				Element.show( "page_texte4__" + cpt );
			}
			else
			{
				Element.hide( "page_actu2__" + cpt );
				Element.show( "page_lien3__" + cpt );
				Element.hide( "page_texte3__" + cpt );
				Element.show( "page_lien4__" + cpt );
				Element.hide( "page_texte4__" + cpt );
			}
		}
	}
}


function page__cacher_pages2()
{	
	for(var i=1;i<=nbr_element_pagination2;i++)
		Element.hide('page_actu2__'+i);
}

function page_montrer_toutes_les_pages2()
{	
	for(var i=1;i<=nbr_element_pagination2;i++)
		Element.show('page_actu2__'+i);
}

///////////////////////////////////////////////////
// gestion de la pagination pour un 3eme onglet //
/////////////////////////////////////////////////
var page_num_page_actuelle3 = 0;
var nbr_element_pagination3 = 0;
	
function page_montrer_page3( num_page )
{	
	milieu_element_pagination = Math.round(nbr_element_pagination3/2);	
	interval_min = milieu_element_pagination - 1;
	interval_max = milieu_element_pagination + 1;
	dernier_prod = nbr_element_pagination3 - 2;
	page_num_page_actuelle3 = num_page;
	
	for( var cpt=1; cpt<=nbr_element_pagination3; cpt++ )
	{
		if( nbr_element_pagination3 > 9 )
		{
			Element.hide( "span_texte5__" + cpt );
			Element.hide( "span_texte6__" + cpt );
			
			if( cpt == num_page )
			{
				Element.show( "page_actu3__" + cpt );
				Element.hide( "page_lien5__" + cpt );
				Element.show( "page_texte5__" + cpt );
				Element.hide( "page_lien6__" + cpt );
				Element.show( "page_texte6__" + cpt );
			}
			else if( ( cpt+1 == num_page ) || ( cpt-1 == num_page ) || ( cpt == nbr_element_pagination3 ) || ( cpt == nbr_element_pagination3-1 ) || ( cpt == 1 ) || ( cpt == 2 ) )
			{
				Element.hide( "page_actu3__" + cpt );
				Element.show( "page_lien5__" + cpt );
				Element.hide( "page_texte5__" + cpt );
				Element.show( "page_lien6__" + cpt );
				Element.hide( "page_texte6__" + cpt );
			}
			else
			{
				Element.hide( "page_actu3__" + cpt );
				Element.hide( "page_lien5__" + cpt );
				Element.hide( "page_texte5__" + cpt );
				Element.hide( "page_lien6__" + cpt );
				Element.hide( "page_texte6__" + cpt );
			}
			
			var element_plus_2 = num_page + 2;
			var element_moins_2 = num_page - 2;
			if( ( $( "page_lien5__" + element_plus_2 ) ) && ( $( "page_lien5__" + element_plus_2 ).style.display == 'none' ) && ( $( "page_texte5__" + element_plus_2 ).style.display == 'none' ) )
			{
				Element.show( "span_texte5__" + element_plus_2 );
				Element.show( "span_texte6__" + element_plus_2 );
			}
			if( ( $( "page_lien5__" + element_moins_2 ) ) && ( $( "page_lien5__" + element_moins_2 ).style.display == 'none' ) && ( $( "page_texte5__" + element_moins_2 ).style.display == 'none' ) )
			{
				Element.show( "span_texte5__" + element_moins_2 );
				Element.show( "span_texte6__" + element_moins_2 );
			}
		}
		else
		{
			if( cpt == num_page )
			{
				Element.show( "page_actu3__" + cpt );
				Element.hide( "page_lien5__" + cpt );
				Element.show( "page_texte5__" + cpt );
				Element.hide( "page_lien6__" + cpt );
				Element.show( "page_texte6__" + cpt );
			}
			else
			{
				Element.hide( "page_actu3__" + cpt );
				Element.show( "page_lien5__" + cpt );
				Element.hide( "page_texte5__" + cpt );
				Element.show( "page_lien6__" + cpt );
				Element.hide( "page_texte6__" + cpt );
			}
		}
	}
}


function page__cacher_pages3()
{	
	for(var i=1;i<=nbr_element_pagination3;i++)
		Element.hide('page_actu3__'+i);
}

function page_montrer_toutes_les_pages2()
{	
	for(var i=1;i<=nbr_element_pagination3;i++)
		Element.show('page_actu3__'+i);
}


/* nouvelle fonction service mesures */
function calcul2( type )
{
	transmettre_log_service_automatise( 'S_auto_5' );
	if(type == "tempe")
	{
		valeur = document.conversion.val_tempe2.value
		unite_1 = document.conversion.unit_tempe1[document.conversion.unit_tempe1.selectedIndex].value
		unite_2 = document.conversion.unit_tempe2[document.conversion.unit_tempe2.selectedIndex].value
		if( ( unite_1 == "vide" ) || ( unite_2 == "vide" ) )
			return 1;
			
		if( unite_1 == 0 )
		{
			if( unite_2 == 0 )
				document.conversion.val_tempe1.value = document.conversion.val_tempe2.value;
			else
			{
				x = (valeur - 32) / 1.8;
				x = x * 1000;
				x = Math.round(x);
				x = x / 1000;
				document.conversion.val_tempe1.value = x;
			}
		}
		else
		{
			if( unite_2 == 0 )
			{
				x = (valeur * 1.8) + 32;
				x = x * 1000;
				x = Math.round(x);
				x = x / 1000;
				document.conversion.val_tempe1.value = x;
			}
			else
				document.conversion.val_tempe1.value = document.conversion.val_tempe2.value;
		}
	}
	else
	{
		valeur = eval("document.conversion.val_"+ type +"2.value")
		unite_1 = eval("document.conversion.unit_"+ type +"1[document.conversion.unit_"+ type +"1.selectedIndex].value")
		unite_2 = eval("document.conversion.unit_"+ type +"2[document.conversion.unit_"+ type +"2.selectedIndex].value")
		if((unite_1 == "vide") || (unite_2 == "vide")){
			return 1;
		}
		x = eval("(valeur * "+ type +"[unite_2].valeur) / "+ type +"[unite_1].valeur")
		x = x * 1000
		x = Math.round(x)
		x = x / 1000
		eval("document.conversion.val_"+ type +"1.value = x")
	}
}




function entityToHtml(string) {
	for (var i in entity_table)
		{
		string = xreplace( string, "&#" + i + ";", String.fromCharCode( i ) );
		string = xreplace( string, "&#x" + Number( i ).toString(16) + ";", String.fromCharCode( i ) );
		string = xreplace( string, entity_table[i], String.fromCharCode( i ) );
		}
	return string;
}

var entity_table = {
  //	34: "&quot;",		// Quotation mark. Not required
  38: "&amp;",		// Ampersand. Applied before everything else in the application
  60: "&lt;",		// Less-than sign
  62: "&gt;",		// Greater-than sign
  //	63: "&#63;",		// Question mark
  //	111: "&#111;",		// Latin small letter o
  160: "&nbsp;",		// Non-breaking space
  161: "&iexcl;",		// Inverted exclamation mark
  162: "&cent;",		// Cent sign
  163: "&pound;",		// Pound sign
  164: "&curren;",	// Currency sign
  165: "&yen;",		// Yen sign
  166: "&brvbar;",	// Broken vertical bar
  167: "&sect;",		// Section sign
  168: "&uml;",		// Diaeresis
  169: "&copy;",		// Copyright sign
  170: "&ordf;",		// Feminine ordinal indicator
  171: "&laquo;",		// Left-pointing double angle quotation mark
  172: "&not;",		// Not sign
  173: "&shy;",		// Soft hyphen
  174: "&reg;",		// Registered sign
  175: "&macr;",		// Macron
  176: "&deg;",		// Degree sign
  177: "&plusmn;",	// Plus-minus sign
  178: "&sup2;",		// Superscript two
  179: "&sup3;",		// Superscript three
  180: "&acute;",		// Acute accent
  181: "&micro;",		// Micro sign
  182: "&para;",		// Pilcrow sign
  183: "&middot;",	// Middle dot
  184: "&cedil;",		// Cedilla
  185: "&sup1;",		// Superscript one
  186: "&ordm;",		// Masculine ordinal indicator
  187: "&raquo;",		// Right-pointing double angle quotation mark
  188: "&frac14;",	// Vulgar fraction one-quarter
  189: "&frac12;",	// Vulgar fraction one-half
  190: "&frac34;",	// Vulgar fraction three-quarters
  191: "&iquest;",	// Inverted question mark
  192: "&Agrave;",	// A with grave
  193: "&Aacute;",	// A with acute
  194: "&Acirc;",		// A with circumflex
  195: "&Atilde;",	// A with tilde
  196: "&Auml;",		// A with diaeresis
  197: "&Aring;",		// A with ring above
  198: "&AElig;",		// AE
  199: "&Ccedil;",	// C with cedilla
  200: "&Egrave;",	// E with grave
  201: "&Eacute;",	// E with acute
  202: "&Ecirc;",		// E with circumflex
  203: "&Euml;",		// E with diaeresis
  204: "&Igrave;",	// I with grave
  205: "&Iacute;",	// I with acute
  206: "&Icirc;",		// I with circumflex
  207: "&Iuml;",		// I with diaeresis
  208: "&ETH;",		// Eth
  209: "&Ntilde;",	// N with tilde
  210: "&Ograve;",	// O with grave
  211: "&Oacute;",	// O with acute
  212: "&Ocirc;",		// O with circumflex
  213: "&Otilde;",	// O with tilde
  214: "&Ouml;",		// O with diaeresis
  215: "&times;",		// Multiplication sign
  216: "&Oslash;",	// O with stroke
  217: "&Ugrave;",	// U with grave
  218: "&Uacute;",	// U with acute
  219: "&Ucirc;",		// U with circumflex
  220: "&Uuml;",		// U with diaeresis
  221: "&Yacute;",	// Y with acute
  222: "&THORN;",		// Thorn
  223: "&szlig;",		// Sharp s. Also known as ess-zed
  224: "&agrave;",	// a with grave
  225: "&aacute;",	// a with acute
  226: "&acirc;",		// a with circumflex
  227: "&atilde;",	// a with tilde
  228: "&auml;",		// a with diaeresis
  229: "&aring;",		// a with ring above
  230: "&aelig;",		// ae. Also known as ligature ae
  231: "&ccedil;",	// c with cedilla
  232: "&egrave;",	// e with grave
  233: "&eacute;",	// e with acute
  234: "&ecirc;",		// e with circumflex
  235: "&euml;",		// e with diaeresis
  236: "&igrave;",	// i with grave
  237: "&iacute;",	// i with acute
  238: "&icirc;",		// i with circumflex
  239: "&iuml;",		// i with diaeresis
  240: "&eth;",		// eth
  241: "&ntilde;",	// n with tilde
  242: "&ograve;",	// o with grave
  243: "&oacute;",	// o with acute
  244: "&ocirc;",		// o with circumflex
  245: "&otilde;",	// o with tilde
  246: "&ouml;",		// o with diaeresis
  247: "&divide;",	// Division sign
  248: "&oslash;",	// o with stroke. Also known as o with slash
  249: "&ugrave;",	// u with grave
  250: "&uacute;",	// u with acute
  251: "&ucirc;",		// u with circumflex
  252: "&uuml;",		// u with diaeresis
  253: "&yacute;",	// y with acute
  254: "&thorn;",		// thorn
  255: "&yuml;",		// y with diaeresis
  264: "&#264;",		// Latin capital letter C with circumflex
  265: "&#265;",		// Latin small letter c with circumflex
  338: "&OElig;",		// Latin capital ligature OE
  339: "&oelig;",		// Latin small ligature oe
  352: "&Scaron;",	// Latin capital letter S with caron
  353: "&scaron;",	// Latin small letter s with caron
  372: "&#372;",		// Latin capital letter W with circumflex
  373: "&#373;",		// Latin small letter w with circumflex
  374: "&#374;",		// Latin capital letter Y with circumflex
  375: "&#375;",		// Latin small letter y with circumflex
  376: "&Yuml;",		// Latin capital letter Y with diaeresis
  402: "&fnof;",		// Latin small f with hook, function, florin
  710: "&circ;",		// Modifier letter circumflex accent
  732: "&tilde;",		// Small tilde
  913: "&Alpha;",		// Alpha
  914: "&Beta;",		// Beta
  915: "&Gamma;",		// Gamma
  916: "&Delta;",		// Delta
  917: "&Epsilon;",	// Epsilon
  918: "&Zeta;",		// Zeta
  919: "&Eta;",		// Eta
  920: "&Theta;",		// Theta
  921: "&Iota;",		// Iota
  922: "&Kappa;",		// Kappa
  923: "&Lambda;",	// Lambda
  924: "&Mu;",		// Mu
  925: "&Nu;",		// Nu
  926: "&Xi;",		// Xi
  927: "&Omicron;",	// Omicron
  928: "&Pi;",		// Pi
  929: "&Rho;",		// Rho
  931: "&Sigma;",		// Sigma
  932: "&Tau;",		// Tau
  933: "&Upsilon;",	// Upsilon
  934: "&Phi;",		// Phi
  935: "&Chi;",		// Chi
  936: "&Psi;",		// Psi
  937: "&Omega;",		// Omega
  945: "&alpha;",		// alpha
  946: "&beta;",		// beta
  947: "&gamma;",		// gamma
  948: "&delta;",		// delta
  949: "&epsilon;",	// epsilon
  950: "&zeta;",		// zeta
  951: "&eta;",		// eta
  952: "&theta;",		// theta
  953: "&iota;",		// iota
  954: "&kappa;",		// kappa
  955: "&lambda;",	// lambda
  956: "&mu;",		// mu
  957: "&nu;",		// nu
  958: "&xi;",		// xi
  959: "&omicron;",	// omicron
  960: "&pi;",		// pi
  961: "&rho;",		// rho
  962: "&sigmaf;",	// sigmaf
  963: "&sigma;",		// sigma
  964: "&tau;",		// tau
  965: "&upsilon;",	// upsilon
  966: "&phi;",		// phi
  967: "&chi;",		// chi
  968: "&psi;",		// psi
  969: "&omega;",		// omega
  977: "&thetasym;",	// Theta symbol
  978: "&upsih;",		// Greek upsilon with hook symbol
  982: "&piv;",		// Pi symbol
  8194: "&ensp;",		// En space
  8195: "&emsp;",		// Em space
  8201: "&thinsp;",	// Thin space
  8204: "&zwnj;",		// Zero width non-joiner
  8205: "&zwj;",		// Zero width joiner
  8206: "&lrm;",		// Left-to-right mark
  8207: "&rlm;",		// Right-to-left mark
  8211: "&ndash;",	// En dash
  8212: "&mdash;",	// Em dash
  8216: "&lsquo;",	// Left single quotation mark
  8217: "&rsquo;",	// Right single quotation mark
  8218: "&sbquo;",	// Single low-9 quotation mark
  8220: "&ldquo;",	// Left double quotation mark
  8221: "&rdquo;",	// Right double quotation mark
  8222: "&bdquo;",	// Double low-9 quotation mark
  8224: "&dagger;",	// Dagger
  8225: "&Dagger;",	// Double dagger
  8226: "&bull;",		// Bullet
  8230: "&hellip;",	// Horizontal ellipsis
  8240: "&permil;",	// Per mille sign
  8242: "&prime;",	// Prime
  8243: "&Prime;",	// Double Prime
  8249: "&lsaquo;",	// Single left-pointing angle quotation
  8250: "&rsaquo;",	// Single right-pointing angle quotation
  8254: "&oline;",	// Overline
  8260: "&frasl;",	// Fraction Slash
  8364: "&euro;",		// Euro sign
  8472: "&weierp;",	// Script capital
  8465: "&image;",	// Blackletter capital I
  8476: "&real;",		// Blackletter capital R
  8482: "&trade;",	// Trade mark sign
  8501: "&alefsym;",	// Alef symbol
  8592: "&larr;",		// Leftward arrow
  8593: "&uarr;",		// Upward arrow
  8594: "&rarr;",		// Rightward arrow
  8595: "&darr;",		// Downward arrow
  8596: "&harr;",		// Left right arrow
  8629: "&crarr;",	// Downward arrow with corner leftward. Also known as carriage return
  8656: "&lArr;",		// Leftward double arrow. ISO 10646 does not say that lArr is the same as the 'is implied by' arrow but also does not have any other character for that function. So ? lArr can be used for 'is implied by' as ISOtech suggests
  8657: "&uArr;",		// Upward double arrow
  8658: "&rArr;",		// Rightward double arrow. ISO 10646 does not say this is the 'implies' character but does not have another character with this function so ? rArr can be used for 'implies' as ISOtech suggests
  8659: "&dArr;",		// Downward double arrow
  8660: "&hArr;",		// Left-right double arrow
  // Mathematical Operators
  8704: "&forall;",	// For all
  8706: "&part;",		// Partial differential
  8707: "&exist;",	// There exists
  8709: "&empty;",	// Empty set. Also known as null set and diameter
  8711: "&nabla;",	// Nabla. Also known as backward difference
  8712: "&isin;",		// Element of
  8713: "&notin;",	// Not an element of
  8715: "&ni;",		// Contains as member
  8719: "&prod;",		// N-ary product. Also known as product sign. Prod is not the same character as U+03A0 'greek capital letter pi' though the same glyph might be used for both
  8721: "&sum;",		// N-ary summation. Sum is not the same character as U+03A3 'greek capital letter sigma' though the same glyph might be used for both
  8722: "&minus;",	// Minus sign
  8727: "&lowast;",	// Asterisk operator
  8729: "&#8729;",	// Bullet operator
  8730: "&radic;",	// Square root. Also known as radical sign
  8733: "&prop;",		// Proportional to
  8734: "&infin;",	// Infinity
  8736: "&ang;",		// Angle
  8743: "&and;",		// Logical and. Also known as wedge
  8744: "&or;",		// Logical or. Also known as vee
  8745: "&cap;",		// Intersection. Also known as cap
  8746: "&cup;",		// Union. Also known as cup
  8747: "&int;",		// Integral
  8756: "&there4;",	// Therefore
  8764: "&sim;",		// tilde operator. Also known as varies with and similar to. The tilde operator is not the same character as the tilde, U+007E, although the same glyph might be used to represent both
  8773: "&cong;",		// Approximately equal to
  8776: "&asymp;",	// Almost equal to. Also known as asymptotic to
  8800: "&ne;",		// Not equal to
  8801: "&equiv;",	// Identical to
  8804: "&le;",		// Less-than or equal to
  8805: "&ge;",		// Greater-than or equal to
  8834: "&sub;",		// Subset of
  8835: "&sup;",		// Superset of. Note that nsup, 'not a superset of, U+2283' is not covered by the Symbol font encoding and is not included.
  8836: "&nsub;",		// Not a subset of
  8838: "&sube;",		// Subset of or equal to
  8839: "&supe;",		// Superset of or equal to
  8853: "&oplus;",	// Circled plus. Also known as direct sum
  8855: "&otimes;",	// Circled times. Also known as vector product
  8869: "&perp;",		// Up tack. Also known as orthogonal to and perpendicular
  8901: "&sdot;",		// Dot operator. The dot operator is not the same character as U+00B7 middle dot
  // Miscellaneous Technical
  8968: "&lceil;",	// Left ceiling. Also known as an APL upstile
  8969: "&rceil;",	// Right ceiling
  8970: "&lfloor;",	// left floor. Also known as APL downstile
  8971: "&rfloor;",	// Right floor
  9001: "&lang;",		// Left-pointing angle bracket. Also known as bra. Lang is not the same character as U+003C 'less than'or U+2039 'single left-pointing angle quotation mark'
  9002: "&rang;",		// Right-pointing angle bracket. Also known as ket. Rang is not the same character as U+003E 'greater than' or U+203A 'single right-pointing angle quotation mark'
  // Geometric Shapes
  9642: "&#9642;",	// Black small square
  9643: "&#9643;",	// White small square
  9674: "&loz;",		// Lozenge
  // Miscellaneous Symbols
  9702: "&#9702;",	// White bullet
  9824: "&spades;",	// Black (filled) spade suit
  9827: "&clubs;",	// Black (filled) club suit. Also known as shamrock
  9829: "&hearts;",	// Black (filled) heart suit. Also known as shamrock
  9830: "&diams;"   // Black (filled) diamond suit
}

/* gestion popup email dans service veille, etude memo v2... */
var ma_fonction_a_appeller = '';
var mon_parametre_a_appeller = '';
function lancer_ma_fonction_a_appeller()
{
	ma_fonction_a_appeller( mon_parametre_a_appeller );
}
function verification_presence_email( ma_fonction, param1 )
{
	if( email_de_utilisateur != '' )
		ma_fonction( param1 );
	else
	{
		ma_fonction_a_appeller = ma_fonction;
		mon_parametre_a_appeller = param1;
		zoombox.open( '/commun/statique.php?nom_modele=ajax__veille_ajouter_email&returnflag=Y&langue='+langue+'&AGAMA_langue='+langue, 400, 300 );
	}
}